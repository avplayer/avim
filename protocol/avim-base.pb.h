// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: avim-base.proto

#ifndef PROTOBUF_avim_2dbase_2eproto__INCLUDED
#define PROTOBUF_avim_2dbase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace avim {
namespace proto {
namespace base {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_avim_2dbase_2eproto();
void protobuf_AssignDesc_avim_2dbase_2eproto();
void protobuf_ShutdownFile_avim_2dbase_2eproto();

class avID;
class avimPacket;
class avClientControl;
class avPacketMessage;
class avPacketMessageReplay;
class avPacketMessageReplay_MultiStatus;

enum avimPacket_messagetype {
  avimPacket_messagetype_MESSAGING = 0,
  avimPacket_messagetype_MESSAGING_REPLAY = 1,
  avimPacket_messagetype_CLIENTCONTROL = 2
};
bool avimPacket_messagetype_IsValid(int value);
const avimPacket_messagetype avimPacket_messagetype_messagetype_MIN = avimPacket_messagetype_MESSAGING;
const avimPacket_messagetype avimPacket_messagetype_messagetype_MAX = avimPacket_messagetype_CLIENTCONTROL;
const int avimPacket_messagetype_messagetype_ARRAYSIZE = avimPacket_messagetype_messagetype_MAX + 1;

const ::google::protobuf::EnumDescriptor* avimPacket_messagetype_descriptor();
inline const ::std::string& avimPacket_messagetype_Name(avimPacket_messagetype value) {
  return ::google::protobuf::internal::NameOfEnum(
    avimPacket_messagetype_descriptor(), value);
}
inline bool avimPacket_messagetype_Parse(
    const ::std::string& name, avimPacket_messagetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<avimPacket_messagetype>(
    avimPacket_messagetype_descriptor(), name, value);
}
enum avClientControl_controltype {
  avClientControl_controltype_LOGIN = 0,
  avClientControl_controltype_AUTH_REQUIRED = 1,
  avClientControl_controltype_DIGEST_AUTH = 2
};
bool avClientControl_controltype_IsValid(int value);
const avClientControl_controltype avClientControl_controltype_controltype_MIN = avClientControl_controltype_LOGIN;
const avClientControl_controltype avClientControl_controltype_controltype_MAX = avClientControl_controltype_DIGEST_AUTH;
const int avClientControl_controltype_controltype_ARRAYSIZE = avClientControl_controltype_controltype_MAX + 1;

const ::google::protobuf::EnumDescriptor* avClientControl_controltype_descriptor();
inline const ::std::string& avClientControl_controltype_Name(avClientControl_controltype value) {
  return ::google::protobuf::internal::NameOfEnum(
    avClientControl_controltype_descriptor(), value);
}
inline bool avClientControl_controltype_Parse(
    const ::std::string& name, avClientControl_controltype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<avClientControl_controltype>(
    avClientControl_controltype_descriptor(), name, value);
}
enum avPacketMessageReplay_Status {
  avPacketMessageReplay_Status_DELIVERED = 0,
  avPacketMessageReplay_Status_SUCCESS = 0,
  avPacketMessageReplay_Status_FAILED = 1,
  avPacketMessageReplay_Status_SUCCESS_OFFLINED = 2,
  avPacketMessageReplay_Status_MULTIADDREDD_STATUS_ATTACHED = 3
};
bool avPacketMessageReplay_Status_IsValid(int value);
const avPacketMessageReplay_Status avPacketMessageReplay_Status_Status_MIN = avPacketMessageReplay_Status_DELIVERED;
const avPacketMessageReplay_Status avPacketMessageReplay_Status_Status_MAX = avPacketMessageReplay_Status_MULTIADDREDD_STATUS_ATTACHED;
const int avPacketMessageReplay_Status_Status_ARRAYSIZE = avPacketMessageReplay_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* avPacketMessageReplay_Status_descriptor();
inline const ::std::string& avPacketMessageReplay_Status_Name(avPacketMessageReplay_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    avPacketMessageReplay_Status_descriptor(), value);
}
inline bool avPacketMessageReplay_Status_Parse(
    const ::std::string& name, avPacketMessageReplay_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<avPacketMessageReplay_Status>(
    avPacketMessageReplay_Status_descriptor(), name, value);
}
// ===================================================================

class avID : public ::google::protobuf::Message {
 public:
  avID();
  virtual ~avID();

  avID(const avID& from);

  inline avID& operator=(const avID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avID& default_instance();

  void Swap(avID* other);

  // implements Message ----------------------------------------------

  avID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avID& from);
  void MergeFrom(const avID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string resource = 3;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 3;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional string useragent = 4;
  inline bool has_useragent() const;
  inline void clear_useragent();
  static const int kUseragentFieldNumber = 4;
  inline const ::std::string& useragent() const;
  inline void set_useragent(const ::std::string& value);
  inline void set_useragent(const char* value);
  inline void set_useragent(const char* value, size_t size);
  inline ::std::string* mutable_useragent();
  inline ::std::string* release_useragent();
  inline void set_allocated_useragent(::std::string* useragent);

  // @@protoc_insertion_point(class_scope:avim.proto.base.avID)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_useragent();
  inline void clear_has_useragent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* domain_;
  ::std::string* resource_;
  ::std::string* useragent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_avim_2dbase_2eproto();
  friend void protobuf_AssignDesc_avim_2dbase_2eproto();
  friend void protobuf_ShutdownFile_avim_2dbase_2eproto();

  void InitAsDefaultInstance();
  static avID* default_instance_;
};
// -------------------------------------------------------------------

class avimPacket : public ::google::protobuf::Message {
 public:
  avimPacket();
  virtual ~avimPacket();

  avimPacket(const avimPacket& from);

  inline avimPacket& operator=(const avimPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avimPacket& default_instance();

  void Swap(avimPacket* other);

  // implements Message ----------------------------------------------

  avimPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avimPacket& from);
  void MergeFrom(const avimPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef avimPacket_messagetype messagetype;
  static const messagetype MESSAGING = avimPacket_messagetype_MESSAGING;
  static const messagetype MESSAGING_REPLAY = avimPacket_messagetype_MESSAGING_REPLAY;
  static const messagetype CLIENTCONTROL = avimPacket_messagetype_CLIENTCONTROL;
  static inline bool messagetype_IsValid(int value) {
    return avimPacket_messagetype_IsValid(value);
  }
  static const messagetype messagetype_MIN =
    avimPacket_messagetype_messagetype_MIN;
  static const messagetype messagetype_MAX =
    avimPacket_messagetype_messagetype_MAX;
  static const int messagetype_ARRAYSIZE =
    avimPacket_messagetype_messagetype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  messagetype_descriptor() {
    return avimPacket_messagetype_descriptor();
  }
  static inline const ::std::string& messagetype_Name(messagetype value) {
    return avimPacket_messagetype_Name(value);
  }
  static inline bool messagetype_Parse(const ::std::string& name,
      messagetype* value) {
    return avimPacket_messagetype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .avim.proto.base.avID src = 1;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 1;
  inline const ::avim::proto::base::avID& src() const;
  inline ::avim::proto::base::avID* mutable_src();
  inline ::avim::proto::base::avID* release_src();
  inline void set_allocated_src(::avim::proto::base::avID* src);

  // repeated .avim.proto.base.avID dest = 2;
  inline int dest_size() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 2;
  inline const ::avim::proto::base::avID& dest(int index) const;
  inline ::avim::proto::base::avID* mutable_dest(int index);
  inline ::avim::proto::base::avID* add_dest();
  inline const ::google::protobuf::RepeatedPtrField< ::avim::proto::base::avID >&
      dest() const;
  inline ::google::protobuf::RepeatedPtrField< ::avim::proto::base::avID >*
      mutable_dest();

  // required bool all_ofline = 4 [default = false];
  inline bool has_all_ofline() const;
  inline void clear_all_ofline();
  static const int kAllOflineFieldNumber = 4;
  inline bool all_ofline() const;
  inline void set_all_ofline(bool value);

  // required string application = 3 [default = "avim"];
  inline bool has_application() const;
  inline void clear_application();
  static const int kApplicationFieldNumber = 3;
  inline const ::std::string& application() const;
  inline void set_application(const ::std::string& value);
  inline void set_application(const char* value);
  inline void set_application(const char* value, size_t size);
  inline ::std::string* mutable_application();
  inline ::std::string* release_application();
  inline void set_allocated_application(::std::string* application);

  // required .avim.proto.base.avimPacket.messagetype type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::avim::proto::base::avimPacket_messagetype type() const;
  inline void set_type(::avim::proto::base::avimPacket_messagetype value);

  // optional .avim.proto.base.avPacketMessage avmessage = 6;
  inline bool has_avmessage() const;
  inline void clear_avmessage();
  static const int kAvmessageFieldNumber = 6;
  inline const ::avim::proto::base::avPacketMessage& avmessage() const;
  inline ::avim::proto::base::avPacketMessage* mutable_avmessage();
  inline ::avim::proto::base::avPacketMessage* release_avmessage();
  inline void set_allocated_avmessage(::avim::proto::base::avPacketMessage* avmessage);

  // optional .avim.proto.base.avPacketMessageReplay avmessage_reply = 7;
  inline bool has_avmessage_reply() const;
  inline void clear_avmessage_reply();
  static const int kAvmessageReplyFieldNumber = 7;
  inline const ::avim::proto::base::avPacketMessageReplay& avmessage_reply() const;
  inline ::avim::proto::base::avPacketMessageReplay* mutable_avmessage_reply();
  inline ::avim::proto::base::avPacketMessageReplay* release_avmessage_reply();
  inline void set_allocated_avmessage_reply(::avim::proto::base::avPacketMessageReplay* avmessage_reply);

  // optional .avim.proto.base.avClientControl avctl = 256;
  inline bool has_avctl() const;
  inline void clear_avctl();
  static const int kAvctlFieldNumber = 256;
  inline const ::avim::proto::base::avClientControl& avctl() const;
  inline ::avim::proto::base::avClientControl* mutable_avctl();
  inline ::avim::proto::base::avClientControl* release_avctl();
  inline void set_allocated_avctl(::avim::proto::base::avClientControl* avctl);

  // @@protoc_insertion_point(class_scope:avim.proto.base.avimPacket)
 private:
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_all_ofline();
  inline void clear_has_all_ofline();
  inline void set_has_application();
  inline void clear_has_application();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_avmessage();
  inline void clear_has_avmessage();
  inline void set_has_avmessage_reply();
  inline void clear_has_avmessage_reply();
  inline void set_has_avctl();
  inline void clear_has_avctl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::avim::proto::base::avID* src_;
  ::google::protobuf::RepeatedPtrField< ::avim::proto::base::avID > dest_;
  ::std::string* application_;
  static ::std::string* _default_application_;
  bool all_ofline_;
  int type_;
  ::avim::proto::base::avPacketMessage* avmessage_;
  ::avim::proto::base::avPacketMessageReplay* avmessage_reply_;
  ::avim::proto::base::avClientControl* avctl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_avim_2dbase_2eproto();
  friend void protobuf_AssignDesc_avim_2dbase_2eproto();
  friend void protobuf_ShutdownFile_avim_2dbase_2eproto();

  void InitAsDefaultInstance();
  static avimPacket* default_instance_;
};
// -------------------------------------------------------------------

class avClientControl : public ::google::protobuf::Message {
 public:
  avClientControl();
  virtual ~avClientControl();

  avClientControl(const avClientControl& from);

  inline avClientControl& operator=(const avClientControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avClientControl& default_instance();

  void Swap(avClientControl* other);

  // implements Message ----------------------------------------------

  avClientControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avClientControl& from);
  void MergeFrom(const avClientControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef avClientControl_controltype controltype;
  static const controltype LOGIN = avClientControl_controltype_LOGIN;
  static const controltype AUTH_REQUIRED = avClientControl_controltype_AUTH_REQUIRED;
  static const controltype DIGEST_AUTH = avClientControl_controltype_DIGEST_AUTH;
  static inline bool controltype_IsValid(int value) {
    return avClientControl_controltype_IsValid(value);
  }
  static const controltype controltype_MIN =
    avClientControl_controltype_controltype_MIN;
  static const controltype controltype_MAX =
    avClientControl_controltype_controltype_MAX;
  static const int controltype_ARRAYSIZE =
    avClientControl_controltype_controltype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  controltype_descriptor() {
    return avClientControl_controltype_descriptor();
  }
  static inline const ::std::string& controltype_Name(controltype value) {
    return avClientControl_controltype_Name(value);
  }
  static inline bool controltype_Parse(const ::std::string& name,
      controltype* value) {
    return avClientControl_controltype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string digest = 50;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 50;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const char* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // @@protoc_insertion_point(class_scope:avim.proto.base.avClientControl)
 private:
  inline void set_has_digest();
  inline void clear_has_digest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* digest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_avim_2dbase_2eproto();
  friend void protobuf_AssignDesc_avim_2dbase_2eproto();
  friend void protobuf_ShutdownFile_avim_2dbase_2eproto();

  void InitAsDefaultInstance();
  static avClientControl* default_instance_;
};
// -------------------------------------------------------------------

class avPacketMessage : public ::google::protobuf::Message {
 public:
  avPacketMessage();
  virtual ~avPacketMessage();

  avPacketMessage(const avPacketMessage& from);

  inline avPacketMessage& operator=(const avPacketMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avPacketMessage& default_instance();

  void Swap(avPacketMessage* other);

  // implements Message ----------------------------------------------

  avPacketMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avPacketMessage& from);
  void MergeFrom(const avPacketMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);

  // optional bytes msgblock = 2;
  inline bool has_msgblock() const;
  inline void clear_msgblock();
  static const int kMsgblockFieldNumber = 2;
  inline const ::std::string& msgblock() const;
  inline void set_msgblock(const ::std::string& value);
  inline void set_msgblock(const char* value);
  inline void set_msgblock(const void* value, size_t size);
  inline ::std::string* mutable_msgblock();
  inline ::std::string* release_msgblock();
  inline void set_allocated_msgblock(::std::string* msgblock);

  // @@protoc_insertion_point(class_scope:avim.proto.base.avPacketMessage)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_msgblock();
  inline void clear_has_msgblock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 length_;
  ::std::string* msgblock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_avim_2dbase_2eproto();
  friend void protobuf_AssignDesc_avim_2dbase_2eproto();
  friend void protobuf_ShutdownFile_avim_2dbase_2eproto();

  void InitAsDefaultInstance();
  static avPacketMessage* default_instance_;
};
// -------------------------------------------------------------------

class avPacketMessageReplay_MultiStatus : public ::google::protobuf::Message {
 public:
  avPacketMessageReplay_MultiStatus();
  virtual ~avPacketMessageReplay_MultiStatus();

  avPacketMessageReplay_MultiStatus(const avPacketMessageReplay_MultiStatus& from);

  inline avPacketMessageReplay_MultiStatus& operator=(const avPacketMessageReplay_MultiStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avPacketMessageReplay_MultiStatus& default_instance();

  void Swap(avPacketMessageReplay_MultiStatus* other);

  // implements Message ----------------------------------------------

  avPacketMessageReplay_MultiStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avPacketMessageReplay_MultiStatus& from);
  void MergeFrom(const avPacketMessageReplay_MultiStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .avim.proto.base.avPacketMessageReplay.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::avim::proto::base::avPacketMessageReplay_Status status() const;
  inline void set_status(::avim::proto::base::avPacketMessageReplay_Status value);

  // required .avim.proto.base.avID avid = 2;
  inline bool has_avid() const;
  inline void clear_avid();
  static const int kAvidFieldNumber = 2;
  inline const ::avim::proto::base::avID& avid() const;
  inline ::avim::proto::base::avID* mutable_avid();
  inline ::avim::proto::base::avID* release_avid();
  inline void set_allocated_avid(::avim::proto::base::avID* avid);

  // @@protoc_insertion_point(class_scope:avim.proto.base.avPacketMessageReplay.MultiStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_avid();
  inline void clear_has_avid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::avim::proto::base::avID* avid_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_avim_2dbase_2eproto();
  friend void protobuf_AssignDesc_avim_2dbase_2eproto();
  friend void protobuf_ShutdownFile_avim_2dbase_2eproto();

  void InitAsDefaultInstance();
  static avPacketMessageReplay_MultiStatus* default_instance_;
};
// -------------------------------------------------------------------

class avPacketMessageReplay : public ::google::protobuf::Message {
 public:
  avPacketMessageReplay();
  virtual ~avPacketMessageReplay();

  avPacketMessageReplay(const avPacketMessageReplay& from);

  inline avPacketMessageReplay& operator=(const avPacketMessageReplay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avPacketMessageReplay& default_instance();

  void Swap(avPacketMessageReplay* other);

  // implements Message ----------------------------------------------

  avPacketMessageReplay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avPacketMessageReplay& from);
  void MergeFrom(const avPacketMessageReplay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef avPacketMessageReplay_MultiStatus MultiStatus;

  typedef avPacketMessageReplay_Status Status;
  static const Status DELIVERED = avPacketMessageReplay_Status_DELIVERED;
  static const Status SUCCESS = avPacketMessageReplay_Status_SUCCESS;
  static const Status FAILED = avPacketMessageReplay_Status_FAILED;
  static const Status SUCCESS_OFFLINED = avPacketMessageReplay_Status_SUCCESS_OFFLINED;
  static const Status MULTIADDREDD_STATUS_ATTACHED = avPacketMessageReplay_Status_MULTIADDREDD_STATUS_ATTACHED;
  static inline bool Status_IsValid(int value) {
    return avPacketMessageReplay_Status_IsValid(value);
  }
  static const Status Status_MIN =
    avPacketMessageReplay_Status_Status_MIN;
  static const Status Status_MAX =
    avPacketMessageReplay_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    avPacketMessageReplay_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return avPacketMessageReplay_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return avPacketMessageReplay_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return avPacketMessageReplay_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .avim.proto.base.avPacketMessageReplay.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::avim::proto::base::avPacketMessageReplay_Status status() const;
  inline void set_status(::avim::proto::base::avPacketMessageReplay_Status value);

  // optional .avim.proto.base.avPacketMessageReplay.MultiStatus multistatus = 2;
  inline bool has_multistatus() const;
  inline void clear_multistatus();
  static const int kMultistatusFieldNumber = 2;
  inline const ::avim::proto::base::avPacketMessageReplay_MultiStatus& multistatus() const;
  inline ::avim::proto::base::avPacketMessageReplay_MultiStatus* mutable_multistatus();
  inline ::avim::proto::base::avPacketMessageReplay_MultiStatus* release_multistatus();
  inline void set_allocated_multistatus(::avim::proto::base::avPacketMessageReplay_MultiStatus* multistatus);

  // @@protoc_insertion_point(class_scope:avim.proto.base.avPacketMessageReplay)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_multistatus();
  inline void clear_has_multistatus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::avim::proto::base::avPacketMessageReplay_MultiStatus* multistatus_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_avim_2dbase_2eproto();
  friend void protobuf_AssignDesc_avim_2dbase_2eproto();
  friend void protobuf_ShutdownFile_avim_2dbase_2eproto();

  void InitAsDefaultInstance();
  static avPacketMessageReplay* default_instance_;
};
// ===================================================================


// ===================================================================

// avID

// required string username = 1;
inline bool avID::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avID::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avID::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avID::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& avID::username() const {
  return *username_;
}
inline void avID::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void avID::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void avID::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avID::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* avID::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void avID::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string domain = 2;
inline bool avID::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avID::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avID::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avID::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& avID::domain() const {
  return *domain_;
}
inline void avID::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void avID::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void avID::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avID::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* avID::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void avID::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resource = 3;
inline bool avID::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void avID::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void avID::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void avID::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& avID::resource() const {
  return *resource_;
}
inline void avID::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void avID::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void avID::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avID::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* avID::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void avID::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string useragent = 4;
inline bool avID::has_useragent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void avID::set_has_useragent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void avID::clear_has_useragent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void avID::clear_useragent() {
  if (useragent_ != &::google::protobuf::internal::kEmptyString) {
    useragent_->clear();
  }
  clear_has_useragent();
}
inline const ::std::string& avID::useragent() const {
  return *useragent_;
}
inline void avID::set_useragent(const ::std::string& value) {
  set_has_useragent();
  if (useragent_ == &::google::protobuf::internal::kEmptyString) {
    useragent_ = new ::std::string;
  }
  useragent_->assign(value);
}
inline void avID::set_useragent(const char* value) {
  set_has_useragent();
  if (useragent_ == &::google::protobuf::internal::kEmptyString) {
    useragent_ = new ::std::string;
  }
  useragent_->assign(value);
}
inline void avID::set_useragent(const char* value, size_t size) {
  set_has_useragent();
  if (useragent_ == &::google::protobuf::internal::kEmptyString) {
    useragent_ = new ::std::string;
  }
  useragent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avID::mutable_useragent() {
  set_has_useragent();
  if (useragent_ == &::google::protobuf::internal::kEmptyString) {
    useragent_ = new ::std::string;
  }
  return useragent_;
}
inline ::std::string* avID::release_useragent() {
  clear_has_useragent();
  if (useragent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = useragent_;
    useragent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void avID::set_allocated_useragent(::std::string* useragent) {
  if (useragent_ != &::google::protobuf::internal::kEmptyString) {
    delete useragent_;
  }
  if (useragent) {
    set_has_useragent();
    useragent_ = useragent;
  } else {
    clear_has_useragent();
    useragent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// avimPacket

// required .avim.proto.base.avID src = 1;
inline bool avimPacket::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avimPacket::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avimPacket::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avimPacket::clear_src() {
  if (src_ != NULL) src_->::avim::proto::base::avID::Clear();
  clear_has_src();
}
inline const ::avim::proto::base::avID& avimPacket::src() const {
  return src_ != NULL ? *src_ : *default_instance_->src_;
}
inline ::avim::proto::base::avID* avimPacket::mutable_src() {
  set_has_src();
  if (src_ == NULL) src_ = new ::avim::proto::base::avID;
  return src_;
}
inline ::avim::proto::base::avID* avimPacket::release_src() {
  clear_has_src();
  ::avim::proto::base::avID* temp = src_;
  src_ = NULL;
  return temp;
}
inline void avimPacket::set_allocated_src(::avim::proto::base::avID* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
}

// repeated .avim.proto.base.avID dest = 2;
inline int avimPacket::dest_size() const {
  return dest_.size();
}
inline void avimPacket::clear_dest() {
  dest_.Clear();
}
inline const ::avim::proto::base::avID& avimPacket::dest(int index) const {
  return dest_.Get(index);
}
inline ::avim::proto::base::avID* avimPacket::mutable_dest(int index) {
  return dest_.Mutable(index);
}
inline ::avim::proto::base::avID* avimPacket::add_dest() {
  return dest_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::avim::proto::base::avID >&
avimPacket::dest() const {
  return dest_;
}
inline ::google::protobuf::RepeatedPtrField< ::avim::proto::base::avID >*
avimPacket::mutable_dest() {
  return &dest_;
}

// required bool all_ofline = 4 [default = false];
inline bool avimPacket::has_all_ofline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void avimPacket::set_has_all_ofline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void avimPacket::clear_has_all_ofline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void avimPacket::clear_all_ofline() {
  all_ofline_ = false;
  clear_has_all_ofline();
}
inline bool avimPacket::all_ofline() const {
  return all_ofline_;
}
inline void avimPacket::set_all_ofline(bool value) {
  set_has_all_ofline();
  all_ofline_ = value;
}

// required string application = 3 [default = "avim"];
inline bool avimPacket::has_application() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void avimPacket::set_has_application() {
  _has_bits_[0] |= 0x00000008u;
}
inline void avimPacket::clear_has_application() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void avimPacket::clear_application() {
  if (application_ != _default_application_) {
    application_->assign(*_default_application_);
  }
  clear_has_application();
}
inline const ::std::string& avimPacket::application() const {
  return *application_;
}
inline void avimPacket::set_application(const ::std::string& value) {
  set_has_application();
  if (application_ == _default_application_) {
    application_ = new ::std::string;
  }
  application_->assign(value);
}
inline void avimPacket::set_application(const char* value) {
  set_has_application();
  if (application_ == _default_application_) {
    application_ = new ::std::string;
  }
  application_->assign(value);
}
inline void avimPacket::set_application(const char* value, size_t size) {
  set_has_application();
  if (application_ == _default_application_) {
    application_ = new ::std::string;
  }
  application_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avimPacket::mutable_application() {
  set_has_application();
  if (application_ == _default_application_) {
    application_ = new ::std::string(*_default_application_);
  }
  return application_;
}
inline ::std::string* avimPacket::release_application() {
  clear_has_application();
  if (application_ == _default_application_) {
    return NULL;
  } else {
    ::std::string* temp = application_;
    application_ = const_cast< ::std::string*>(_default_application_);
    return temp;
  }
}
inline void avimPacket::set_allocated_application(::std::string* application) {
  if (application_ != _default_application_) {
    delete application_;
  }
  if (application) {
    set_has_application();
    application_ = application;
  } else {
    clear_has_application();
    application_ = const_cast< ::std::string*>(_default_application_);
  }
}

// required .avim.proto.base.avimPacket.messagetype type = 5;
inline bool avimPacket::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void avimPacket::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void avimPacket::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void avimPacket::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::avim::proto::base::avimPacket_messagetype avimPacket::type() const {
  return static_cast< ::avim::proto::base::avimPacket_messagetype >(type_);
}
inline void avimPacket::set_type(::avim::proto::base::avimPacket_messagetype value) {
  assert(::avim::proto::base::avimPacket_messagetype_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .avim.proto.base.avPacketMessage avmessage = 6;
inline bool avimPacket::has_avmessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void avimPacket::set_has_avmessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void avimPacket::clear_has_avmessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void avimPacket::clear_avmessage() {
  if (avmessage_ != NULL) avmessage_->::avim::proto::base::avPacketMessage::Clear();
  clear_has_avmessage();
}
inline const ::avim::proto::base::avPacketMessage& avimPacket::avmessage() const {
  return avmessage_ != NULL ? *avmessage_ : *default_instance_->avmessage_;
}
inline ::avim::proto::base::avPacketMessage* avimPacket::mutable_avmessage() {
  set_has_avmessage();
  if (avmessage_ == NULL) avmessage_ = new ::avim::proto::base::avPacketMessage;
  return avmessage_;
}
inline ::avim::proto::base::avPacketMessage* avimPacket::release_avmessage() {
  clear_has_avmessage();
  ::avim::proto::base::avPacketMessage* temp = avmessage_;
  avmessage_ = NULL;
  return temp;
}
inline void avimPacket::set_allocated_avmessage(::avim::proto::base::avPacketMessage* avmessage) {
  delete avmessage_;
  avmessage_ = avmessage;
  if (avmessage) {
    set_has_avmessage();
  } else {
    clear_has_avmessage();
  }
}

// optional .avim.proto.base.avPacketMessageReplay avmessage_reply = 7;
inline bool avimPacket::has_avmessage_reply() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void avimPacket::set_has_avmessage_reply() {
  _has_bits_[0] |= 0x00000040u;
}
inline void avimPacket::clear_has_avmessage_reply() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void avimPacket::clear_avmessage_reply() {
  if (avmessage_reply_ != NULL) avmessage_reply_->::avim::proto::base::avPacketMessageReplay::Clear();
  clear_has_avmessage_reply();
}
inline const ::avim::proto::base::avPacketMessageReplay& avimPacket::avmessage_reply() const {
  return avmessage_reply_ != NULL ? *avmessage_reply_ : *default_instance_->avmessage_reply_;
}
inline ::avim::proto::base::avPacketMessageReplay* avimPacket::mutable_avmessage_reply() {
  set_has_avmessage_reply();
  if (avmessage_reply_ == NULL) avmessage_reply_ = new ::avim::proto::base::avPacketMessageReplay;
  return avmessage_reply_;
}
inline ::avim::proto::base::avPacketMessageReplay* avimPacket::release_avmessage_reply() {
  clear_has_avmessage_reply();
  ::avim::proto::base::avPacketMessageReplay* temp = avmessage_reply_;
  avmessage_reply_ = NULL;
  return temp;
}
inline void avimPacket::set_allocated_avmessage_reply(::avim::proto::base::avPacketMessageReplay* avmessage_reply) {
  delete avmessage_reply_;
  avmessage_reply_ = avmessage_reply;
  if (avmessage_reply) {
    set_has_avmessage_reply();
  } else {
    clear_has_avmessage_reply();
  }
}

// optional .avim.proto.base.avClientControl avctl = 256;
inline bool avimPacket::has_avctl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void avimPacket::set_has_avctl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void avimPacket::clear_has_avctl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void avimPacket::clear_avctl() {
  if (avctl_ != NULL) avctl_->::avim::proto::base::avClientControl::Clear();
  clear_has_avctl();
}
inline const ::avim::proto::base::avClientControl& avimPacket::avctl() const {
  return avctl_ != NULL ? *avctl_ : *default_instance_->avctl_;
}
inline ::avim::proto::base::avClientControl* avimPacket::mutable_avctl() {
  set_has_avctl();
  if (avctl_ == NULL) avctl_ = new ::avim::proto::base::avClientControl;
  return avctl_;
}
inline ::avim::proto::base::avClientControl* avimPacket::release_avctl() {
  clear_has_avctl();
  ::avim::proto::base::avClientControl* temp = avctl_;
  avctl_ = NULL;
  return temp;
}
inline void avimPacket::set_allocated_avctl(::avim::proto::base::avClientControl* avctl) {
  delete avctl_;
  avctl_ = avctl;
  if (avctl) {
    set_has_avctl();
  } else {
    clear_has_avctl();
  }
}

// -------------------------------------------------------------------

// avClientControl

// optional string digest = 50;
inline bool avClientControl::has_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avClientControl::set_has_digest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avClientControl::clear_has_digest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avClientControl::clear_digest() {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& avClientControl::digest() const {
  return *digest_;
}
inline void avClientControl::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void avClientControl::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
}
inline void avClientControl::set_digest(const char* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avClientControl::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    digest_ = new ::std::string;
  }
  return digest_;
}
inline ::std::string* avClientControl::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void avClientControl::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::kEmptyString) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// avPacketMessage

// required uint64 length = 1;
inline bool avPacketMessage::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avPacketMessage::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avPacketMessage::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avPacketMessage::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 avPacketMessage::length() const {
  return length_;
}
inline void avPacketMessage::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// optional bytes msgblock = 2;
inline bool avPacketMessage::has_msgblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avPacketMessage::set_has_msgblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avPacketMessage::clear_has_msgblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avPacketMessage::clear_msgblock() {
  if (msgblock_ != &::google::protobuf::internal::kEmptyString) {
    msgblock_->clear();
  }
  clear_has_msgblock();
}
inline const ::std::string& avPacketMessage::msgblock() const {
  return *msgblock_;
}
inline void avPacketMessage::set_msgblock(const ::std::string& value) {
  set_has_msgblock();
  if (msgblock_ == &::google::protobuf::internal::kEmptyString) {
    msgblock_ = new ::std::string;
  }
  msgblock_->assign(value);
}
inline void avPacketMessage::set_msgblock(const char* value) {
  set_has_msgblock();
  if (msgblock_ == &::google::protobuf::internal::kEmptyString) {
    msgblock_ = new ::std::string;
  }
  msgblock_->assign(value);
}
inline void avPacketMessage::set_msgblock(const void* value, size_t size) {
  set_has_msgblock();
  if (msgblock_ == &::google::protobuf::internal::kEmptyString) {
    msgblock_ = new ::std::string;
  }
  msgblock_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* avPacketMessage::mutable_msgblock() {
  set_has_msgblock();
  if (msgblock_ == &::google::protobuf::internal::kEmptyString) {
    msgblock_ = new ::std::string;
  }
  return msgblock_;
}
inline ::std::string* avPacketMessage::release_msgblock() {
  clear_has_msgblock();
  if (msgblock_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgblock_;
    msgblock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void avPacketMessage::set_allocated_msgblock(::std::string* msgblock) {
  if (msgblock_ != &::google::protobuf::internal::kEmptyString) {
    delete msgblock_;
  }
  if (msgblock) {
    set_has_msgblock();
    msgblock_ = msgblock;
  } else {
    clear_has_msgblock();
    msgblock_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// avPacketMessageReplay_MultiStatus

// required .avim.proto.base.avPacketMessageReplay.Status status = 1;
inline bool avPacketMessageReplay_MultiStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avPacketMessageReplay_MultiStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avPacketMessageReplay_MultiStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avPacketMessageReplay_MultiStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::avim::proto::base::avPacketMessageReplay_Status avPacketMessageReplay_MultiStatus::status() const {
  return static_cast< ::avim::proto::base::avPacketMessageReplay_Status >(status_);
}
inline void avPacketMessageReplay_MultiStatus::set_status(::avim::proto::base::avPacketMessageReplay_Status value) {
  assert(::avim::proto::base::avPacketMessageReplay_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// required .avim.proto.base.avID avid = 2;
inline bool avPacketMessageReplay_MultiStatus::has_avid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avPacketMessageReplay_MultiStatus::set_has_avid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avPacketMessageReplay_MultiStatus::clear_has_avid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avPacketMessageReplay_MultiStatus::clear_avid() {
  if (avid_ != NULL) avid_->::avim::proto::base::avID::Clear();
  clear_has_avid();
}
inline const ::avim::proto::base::avID& avPacketMessageReplay_MultiStatus::avid() const {
  return avid_ != NULL ? *avid_ : *default_instance_->avid_;
}
inline ::avim::proto::base::avID* avPacketMessageReplay_MultiStatus::mutable_avid() {
  set_has_avid();
  if (avid_ == NULL) avid_ = new ::avim::proto::base::avID;
  return avid_;
}
inline ::avim::proto::base::avID* avPacketMessageReplay_MultiStatus::release_avid() {
  clear_has_avid();
  ::avim::proto::base::avID* temp = avid_;
  avid_ = NULL;
  return temp;
}
inline void avPacketMessageReplay_MultiStatus::set_allocated_avid(::avim::proto::base::avID* avid) {
  delete avid_;
  avid_ = avid;
  if (avid) {
    set_has_avid();
  } else {
    clear_has_avid();
  }
}

// -------------------------------------------------------------------

// avPacketMessageReplay

// required .avim.proto.base.avPacketMessageReplay.Status status = 1;
inline bool avPacketMessageReplay::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avPacketMessageReplay::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avPacketMessageReplay::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avPacketMessageReplay::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::avim::proto::base::avPacketMessageReplay_Status avPacketMessageReplay::status() const {
  return static_cast< ::avim::proto::base::avPacketMessageReplay_Status >(status_);
}
inline void avPacketMessageReplay::set_status(::avim::proto::base::avPacketMessageReplay_Status value) {
  assert(::avim::proto::base::avPacketMessageReplay_Status_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .avim.proto.base.avPacketMessageReplay.MultiStatus multistatus = 2;
inline bool avPacketMessageReplay::has_multistatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avPacketMessageReplay::set_has_multistatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avPacketMessageReplay::clear_has_multistatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avPacketMessageReplay::clear_multistatus() {
  if (multistatus_ != NULL) multistatus_->::avim::proto::base::avPacketMessageReplay_MultiStatus::Clear();
  clear_has_multistatus();
}
inline const ::avim::proto::base::avPacketMessageReplay_MultiStatus& avPacketMessageReplay::multistatus() const {
  return multistatus_ != NULL ? *multistatus_ : *default_instance_->multistatus_;
}
inline ::avim::proto::base::avPacketMessageReplay_MultiStatus* avPacketMessageReplay::mutable_multistatus() {
  set_has_multistatus();
  if (multistatus_ == NULL) multistatus_ = new ::avim::proto::base::avPacketMessageReplay_MultiStatus;
  return multistatus_;
}
inline ::avim::proto::base::avPacketMessageReplay_MultiStatus* avPacketMessageReplay::release_multistatus() {
  clear_has_multistatus();
  ::avim::proto::base::avPacketMessageReplay_MultiStatus* temp = multistatus_;
  multistatus_ = NULL;
  return temp;
}
inline void avPacketMessageReplay::set_allocated_multistatus(::avim::proto::base::avPacketMessageReplay_MultiStatus* multistatus) {
  delete multistatus_;
  multistatus_ = multistatus;
  if (multistatus) {
    set_has_multistatus();
  } else {
    clear_has_multistatus();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace base
}  // namespace proto
}  // namespace avim

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::avim::proto::base::avimPacket_messagetype>() {
  return ::avim::proto::base::avimPacket_messagetype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::avim::proto::base::avClientControl_controltype>() {
  return ::avim::proto::base::avClientControl_controltype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::avim::proto::base::avPacketMessageReplay_Status>() {
  return ::avim::proto::base::avPacketMessageReplay_Status_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_avim_2dbase_2eproto__INCLUDED
